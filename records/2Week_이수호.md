# **[체크 리스트]**

## 호감표시 할 때 예외처리 케이스 3가지 처리
- [x] 케이스 4 : 한명의 인스타회원이 다른 인스타회원에게 중복으로 호감표시를 할 수 없습니다.
- [x] 케이스 5 : 한명의 인스타회원이 11명 이상의 호감상대를 등록 할 수 없습니다.
- [x] 케이스 6 : 케이스 4 가 발생했을 때 기존의 사유와 다른 사유로 호감을 표시하는 경우에는 성공으로 처리합니다.

## 네이버 로그인
- [x]  카카오 로그인이 가능한것 처럼, 네이버 로그인으로도 가입 및 로그인 처리가 되도록 합니다.
- [x]  스프링 OAuth2 클라이언트로 구현합니다.
- [x] 네이버 로그인으로 가입한 회원의 providerTypeCode : NAVER


# **[접근 방법]**
## 1주차와 바뀐점
- fromInstaMember -> pushInstaMember (호감을 누른 유저임을 확실하게 나타내기 위해)
- toInstaMember -> pullInstaMember (호감을 받은 유저임을 확실하게 나타내기 위해) <br>
위 두 변수의 이름이 헷갈릴 때가 많아서 변수명을 수정했습니다.

## 호감표시 할 때 예외처리 케이스 3가지 처리
### 1. 중복호감표시X, 중복호감표시시, 코드 옵션이 다르면 수정 로직 구현 (querydsl로 케이스 4 & 6 동시 처리)
- 과제로직에 동적쿼리를 적용해서 작성해보고 싶어서, querydsl을 도입해여 수정 및 중복호감 감지 로직을 구현해보고자 했습니다.
- 우선 먼저 확인한 것은 작성한 likeablePerson이 중복인지 였습니다. 그래서 likeablePersonRepository에 같은 InstaMember로 저장되어있는 호감유저들을 반환하였는데요.
- 이때 querydsl로 호감유저들을 반환하는 동적쿼리를 작성했습니다. 
- 동적쿼리로 가져오는 것은 호감표시를 받은 이름이 같은 인스타멤버 목록을 가져오도록 했습니다. 왜냐하면 이름은 같지만 코드가 다를 경우네는 수정로직을 실행해야하기 때문입니다.
- 이후에 가져온 리스트를 탐색하며 이름은 같지만 코드만 다를 경우에는 수정 로직, 이름과 코드 둘다 같을 경우에는 중복표시X로직을 동작하도록 작성했습니다.

### 2. 유저당 호감표시 인원은 10명을 초과해서는 안된다. (케이스 5)
- 이 부분은 이전 2주차 과제 시작이전에 1WeekFix에서 달아둔 InstaMember 클래스의 pushLikeablePeople변수에서 호감유저 목록을 저장하고 있었기 때문에, 비교를 하면되서 비교적 쉬웠습니다.
- 이때 저는 사이즈 비교시에 정수로 비교하는 것이 아닌 환경변수로 설정한 값으로 비교를 하고 싶었기 때문에, 1주차에서 환경변수를 지정해줬던 것처럼 변수를 지정후 가져와 비교하는 식으로 구성했는데요.
- 이전 주차에는 Enviroment 클래스로 환경변수를 가져왔지만, @Value 어노테이션의 프로퍼티값을 가져오는 것이 좀 더 보기에 직관적이고 제공하는 옵션이 많았기에 @Value로 수정하여 진행했습니다.

## 네이버 로그인
- 네이버 로그인 api는 구글과 카카오와는 다르게 반환되는 oAuth2User의 이름이 JSON 형태입니다.
- 따라서 JSON을 전부 가져와서 세션값을 저장하는 것이 아니라 JSON에서 ID값만을 가져와서 넘겨줘야 하는데요.
- 그러나 바로 해쉬맵으로 넘겨받아서 주려하니 다른 API의 값과 다르고, 해쉬맵형태로 받을 수 없었습니다.
- 따라서 getRegistrationId의 값이 naver일 경우에만 해쉬맵으로 받을 수 있게 하고,<br> request의 attributes값을 받아와서 해쉬맵 형태로 변경할 수 있는 "NaverPricipal" 클래스를 생성해서 id값만을 받아올 수 있도록 작성했습니다.
- NaverPrincipal 클래스를 통해 ProviderId값을 반환해서 네이버의 세션값을 환경변수로 받을 수 있게 했습니다.


# **[특이사항]**
queryDSL로 로직을 작성하고 반환된 쿼리 개수를 보니, 로직이 동작할때마다 3~4개의 쿼리가 발생하는 것을 알게 되었습니다.
그래서 동적쿼리 작성시에는 한번의 쿼리만을 생성할 수 있도록 fetch join을 도입해서 join된 테이블과 함께 하나의 쿼리만을 작성하여 가져올 수 있도록 하였습니다.

# **[Refactoring]**
그런데... 또다른 문제가 발생했습니다.
호감유저를 등록할 때 이름은 같지만 코드가 다를 경우 수정로직이 동작하도록 구성했는데요. 아래 코드는 수정할 LikeablePerson 객체입니다.
LikeablePerson modifyLikeablePerson = likeablePersonRepository.findByPullInstaMember(likeablePerson.getPullInstaMember());
이 수정할 호감유저 객체를 조회할때, 동적로직을 직접 짜서 한게 아니라서 InstaMember와 LikeablePerson 변수하나당 쿼리를 생성해서 결과적으로 5~6개정도 쿼리를 생성하는 것을 알아버렸습니다. (JPA의 그 유명한 N+1문제 발생)
리팩토링 시간에는 이 findByPullInstaMember 조회로직을 querydsl로 작성해서 fetch조인으로 하나의 쿼리로 생성해서 조회를 하도록 해서 N+1문제를 해결해보고자 합니다.

아직 test환경에서 리포지토리에 접근하여 사이즈를 가져와 값 최대치와 비교하는 케이스를 만들지 못했습니다. 테스트환경에서의 리포지토리 접근방식을 공부해서 케이스를 추가해보려합니다.